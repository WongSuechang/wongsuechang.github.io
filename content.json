{"meta":{"title":"WongSuechang's Blogs","subtitle":null,"description":null,"author":"Wong Suechang","url":"http://wongsuechang.github.io"},"pages":[{"title":"android学习","date":"2019-09-24T10:24:40.000Z","updated":"2019-10-29T19:53:34.000Z","comments":true,"path":"android学习/index.html","permalink":"http://wongsuechang.github.io/android%E5%AD%A6%E4%B9%A0/index.html","excerpt":"","text":""},{"title":"关于我","date":"2019-09-24T10:44:57.000Z","updated":"2022-02-16T18:45:32.000Z","comments":true,"path":"关于我/index.html","permalink":"http://wongsuechang.github.io/%E5%85%B3%E4%BA%8E%E6%88%91/index.html","excerpt":"","text":"概况：男 | 30岁(1992年1月2日 ) | 已婚 E-mail：semp@live.cn 地址：上海 手机：18252495961 个人博客：http://wongsuechang.win/ 工作经验2021-04~至今上海赫禾汽车销售有限公司&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;行业：软件 职位：移动开发工程师&amp;nbsp;&amp;nbsp;部门：研发部 独立完成公司移动仓储app。 维护洗车工业务-捞活app。 2016-12~2021-02大器物联科技（广州）有限公司&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;行业：物联网 职位：前端leader&amp;nbsp;&amp;nbsp;部门：研发部 个人在Android开发方面不断学习。参与公司产品的开发，包含了建筑实名制人脸识别解决方案、塔机AI立体安全监测系统、AI智慧大屏2.0等产品。 带领团队不断成长。在自我驱动、业务驱动的双重动力下，带领的团队紧跟公司节奏，成长迅速。 组织实施系统分析、系统架构设计。参与大器产品的系统规划、细分产品、并制定项目任务与项目进度表。制定软件的开发规范并监督执行。 负责部门研发团队管理、过程管理和控制,包括进度安排和控制、风险控制、质量管理、配置管理、任务分工的执行、资源调配、技术规划及技术攻关协调和督导部门的日常工作。 2014-04~2016-11江苏一米智能有限公司&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;行业：互联网职位：iOS工程师&amp;nbsp;&amp;nbsp;部门：开发部 2014&#x2F;12之前，参与android开发，期间完成了公司的wms(移动仓储管理系统)和移动门户(android)的开发; 2015年后，因公司发展需要，开始转向iOS开发，参与并配合同事参与公司多个项目的开发，如移动门户、土壤监测、移动报销、优职管家、睡眠测量等。并协助H5开发小组编写android和iOS端的插件。其中，移动门户作为一款企业级的应用，包含了工作流，企业通讯录，企业移动管理等多方面的功能，目前又新增了用友友信的落地电话功能，帮助企业改善话费补贴额外支出.作为该项目的主要责任人负责版本迭代和正常维护(iOS端，android端和服务器，均有涉及)。 2013-09~2014-04云端网络科技有限公司&amp;nbsp;&amp;nbsp;20人&amp;nbsp;&amp;nbsp;8个月&amp;nbsp;&amp;nbsp;行业：互联网职位：android工程师&amp;nbsp;&amp;nbsp;部门：开发部参与公司校园社交类app的开发，完成部分功能实现。 项目经验2017-09起 建筑实名制人脸识别解决方案 项目描述：&amp;nbsp;&amp;nbsp;建筑实名制人脸识别解决方案是立足于智慧城市”和“互联网+”，结合BIM、云计算、大数据、物联网、移动应用和智能应用等先进技术，提出了一体化的工地实名制系统解决方案，旨在让施工现场的管理更安全、透彻。在实现有效、全面、智能的工地管理的同时，工地实名制人脸识别解决方案可以有效提升行业监管和服务能力，及时发现安全隐患，保障工程质量，实现质量溯源和劳务实名制管理，促进诚信大数据的建立。 责任描述：&amp;nbsp;&amp;nbsp;在项目中承担leader责任，参与整个项目开发计划、测试计划的统筹安排。前期参与与硬件厂商对接，配合硬件部门对android系统进行定制。采用虹软人脸识别方案，实现数据云同步，一端录入，多端识别。在光学指纹识别器或者人脸识别通过后，控制电路开关开闸或者打开指定开关。 2018-10起 塔机AI立体安全监测系统 项目描述：&amp;nbsp;&amp;nbsp;在塔机AI立体安全监测系统中，通过大器安全模块A2传感监测塔机的风速、起升、回转、幅度和高度数据，AI算法根据实时采集的数据，实现安全预警和风险预判的 LEVEL2级别智能辅助驾驶，纵向监测塔机是否有倾斜倒塌风险，横向监测群塔是否有碰撞风险同时把相关的安全信息发送给云端服务器，塔机的管理人员可通过手机端APP、智慧大屏等多终端实时查看到网络中每个塔机的运行情况。在群塔的安全监测系统中，塔机与塔机之间采用分布式架构进行实时通信，从而在单塔的安全监测基础上，能够得到塔机之间的实时运行状态和数据信息，通过AI解决群塔间相互碰撞的问题。 责任描述：&amp;nbsp;&amp;nbsp;作为项目Leader统筹项目。协调硬件部门、Java开发组、算法部门以及android开发组的工作进度，对android系统进行定制化的同时，对接硬件部门协商硬件要求，对数据接口进行定义，参与制定与Socket服务器的通信协议。 自我评价 熟悉android开发，熟练使用开发工具Android Studio，了解android基本组件，能够熟练阅读Retrofit、glide、fastjson等类库源代码和使用。有完整商业项目经验。 了解iOS开发，熟练使用开发工具Xcode,能够参与完整项目开发，并在github上开源页面切换动画https：&#x2F;&#x2F;github.com&#x2F;WongSuechang&#x2F;SCFadeSlideView。 具有抗压能力，能够快速融入团队。"},{"title":"frameworks","date":"2019-09-24T10:26:01.000Z","updated":"2019-10-29T19:53:36.000Z","comments":true,"path":"frameworks/index.html","permalink":"http://wongsuechang.github.io/frameworks/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-23T06:38:49.000Z","updated":"2020-06-10T20:10:34.000Z","comments":false,"path":"tags/index.html","permalink":"http://wongsuechang.github.io/tags/index.html","excerpt":"","text":""},{"title":"app开发","date":"2019-09-24T10:25:22.000Z","updated":"2019-10-29T19:53:36.000Z","comments":true,"path":"app开发/index.html","permalink":"http://wongsuechang.github.io/app%E5%BC%80%E5%8F%91/index.html","excerpt":"","text":""}],"posts":[{"title":"Android代码规范","slug":"Android代码规范","date":"2021-05-07T09:48:12.000Z","updated":"2022-10-17T00:14:28.000Z","comments":true,"path":"2021/05/07/Android代码规范/","link":"","permalink":"http://wongsuechang.github.io/2021/05/07/Android%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/","excerpt":"","text":"前言这份文档参考了 Google Java 编程风格规范和 Google 官方 Android 编码风格规范。该文档仅供参考，只要形成一个统一的风格，见量知其意就可。 术语说明在本文档中，除非另有说明： 术语 class 可表示一个普通类，枚举类，接口或是annotation类型(@interface)术语 comment 只用来指代实现的注释(implementation comments)，我们不使用”documentation comments”一词，而是用 Javadoc。其他的术语说明会偶尔在后面的文档出现。 指南说明本文档中的示例代码并不作为规范，仅供参考。基本格式方面使用 AndroidStudio 默认模板即可（使用格式化快捷键处理后基本符合）。 源文件基础文件名源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为.java。 文件编码：UTF-8源文件编码格式为 UTF-8。 特殊字符空白字符除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：所有其它字符串中的空白字符都要进行转义。制表符不用于缩进（可以在IDE中Tab键设置为若干个空格）。 特殊转义序列对于具有特殊转义序列的任何字符(\\b, \\t, \\n, \\f, \\r, “, ‘及)，我们使用它的转义序列，而不是相应的八进制(比如\\012)或Unicode(比如\\u000a)转义。 非ASCII字符对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\\u221e)，取决于哪个能让代码更易于阅读和理解。 Tip:在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。例如：String unitAbbrev &#x3D; “μs”; | 即使没有注释也非常清晰String unitAbbrev &#x3D; “\\u03bcs”; &#x2F;&#x2F; “μs” | 允许，但没有理由要这样做String unitAbbrev &#x3D; “\\u03bcs”; &#x2F;&#x2F; Greek letter mu, “s” | 允许，但这样做显得笨拙还容易出错String unitAbbrev &#x3D; “\\u03bcs”; | 很糟，读者根本看不出这是什么return ‘\\ufeff’ + content; &#x2F;&#x2F; byte order mark | Good，对于非打印字符，使用转义，并在必要时写上注释 Tip:永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行， 你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话) 源文件结构一个源文件包含(按顺序地)：许可证或版权信息(如有需要)package语句import语句一个顶级类(只有一个)以上每个部分之间用一个空行隔开。 许可证或版权信息如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。 package语句package 语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里) import语句import不要使用通配符即，不要出现类似这样的import语句：import java.util.*; 不要换行import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行) 顺序和间距import语句可分为以下几组，按照这个顺序，每组由一个空行分隔： 1.所有的静态导入独立成组 2.com.google imports(仅当这个源文件是在com.google包下) 3.第三方的包。每个顶级包为一组，字典序。例如：android, com, junit, org, sun 4.java imports5.javax imports组内不空行，按字典序排列。 类声明只有一个顶级类声明每个顶级类都在一个与它同名的源文件中(当然，还包含.java后缀)。例外：package-info.java，该文件中可没有package-info类。 类成员顺序类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。 区块划分建议使用注释将源文件分为明显的区块，区块划分如下 常量声明区 普通成员变量声明区 UI控件成员变量声明区 内部接口声明区 初始化相关方法区 事件响应方法区 普通逻辑方法区 重载的逻辑方法区 发起异步任务方法区 异步任务回调方法区 生命周期回调方法区（除去onCreate()方法） 内部类声明区 类成员排列通用规则 按照发生的先后顺序排列 常量按照使用先后排列 UI控件成员变量按照layout文件中的先后顺序排列 普通成员变量按照使用的先后顺序排列 方法基本上都按照调用的先后顺序在各自区块中排列 相关功能作为小区块放在一起（或者封装掉） 重载：永不分离当一个类有多个构造函数，或是多个同名方法，这些函数&#x2F;方法应该按顺序出现在一起，中间不要放进其它函数&#x2F;方法。 格式术语说明：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。 大括号使用大括号(即使是可选的)大括号与if, else, for, do, while语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。 非空块：K &amp; R 风格对于非空块和块状结构，大括号遵循 Kernighan 和 Ritchie 风格 (Egyptian brackets): 左大括号前不换行左大括号后换行右大括号前换行如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。示例： 1234567891011return new MyClass() &#123; @Override public void method() &#123; if (condition()) &#123; try &#123; something(); &#125; catch (ProblemException e) &#123; recover(); &#125; &#125; &#125;&#125;; 4.8.1节给出了enum类的一些例外。 空块：可以用简洁版本一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。例外：如果它是一个多块语句的一部分(if&#x2F;else 或 try&#x2F;catch&#x2F;finally) ，即使大括号内没内容，右大括号也要换行。示例： 1void doNothing() &#123;&#125; 块缩进：4个空格每当开始一个新的块，缩进增加4个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例) 一行一个语句每个语句后要换行。 列限制：80或100一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。 不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。package和import语句(见3.2节和3.3节)。注释中那些可能被剪切并粘贴到shell中的命令行。 自动换行术语说明：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。 Tip:提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧) 从哪里断开自动换行的基本准则是：更倾向于在更高的语法级别处断开。 如果在非赋值运算符处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与 Google 其它语言的编程风格不同(如 C++ 和 JavaScript )。这条规则也适用于以下”类运算符”符号：点分隔符(.)，类型界限中的 &amp;（)，catch 块中的管道符号(catch (FooException | BarException e)如果在赋值运算符处断开，通常的做法是在该符号后断开(比如&#x3D;，它与前面的内容留在同一行)。这条规则也适用于foreach语句中的分号。方法名或构造函数名与左括号留在同一行。逗号(,)与其前面的内容留在同一行。 自动换行时缩进至少+8个空格自动换行时，第一行后的每一行至少比第一行多缩进8个空格(注意：制表符不用于缩进。见2.3.1节)。当存在连续自动换行时，缩进可能会多缩进不只8个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。 空白垂直空白以下情况需要使用一个空行： 类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。 例外： 两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。在函数体内，语句的逻辑分组间使用空行。类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。要满足本文档中其他节的空行要求(比如3.3节：import语句)多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。 水平空白除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方： 分隔任何保留字与紧随其后的左括号(()(如if, for catch等)。分隔任何保留字与其前面的右大括号(})(如else, catch)。在任何左大括号前({)，两个例外：o @SomeAnnotation({a, b})(不使用空格)。o String[][] x &#x3D; foo;(大括号间没有空格，见下面的Note)。在任何二元或三元运算符的两侧。这也适用于以下”类运算符”符号：o 类型界限中的&amp;()。o catch块中的管道符号(catch (FooException | BarException e)。o foreach语句中的分号。在, : ;及右括号())后如果在一条语句后做注释，则双斜杠(&#x2F;&#x2F;)两边都要空格。这里可以允许多个空格，但没有必要。类型和变量之间：List list。数组初始化中，大括号内的空格是可选的，即new int[] {5, 6}和new int[] { 5, 6 }都是可以的。Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。 水平对齐：不做要求术语说明：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。以下示例先展示未对齐的代码，然后是对齐的代码： 12345private int x; // this is fineprivate Color color; // this tooprivate int x; // permitted, but future editsprivate Color color; // may leave it unaligned Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)。这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。 用小括号来限定组：推荐除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。我们没有理由假设读者能记住整个Java运算符优先级表。 具体结构枚举类枚举常量间用逗号隔开，换行可选。没有方法和文档的枚举类可写成数组初始化的格式： 123456private enum Suit &#123; CLUBS, HEARTS, SPADES, DIAMONDS&#125; 由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。 变量声明每次只声明一个变量不要使用组合声明，比如int a, b;。 需要时才声明，并尽快进行初始化不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。 数组数组初始化：可写成块状结构数组初始化可以写成块状结构，比如，下面的写法都是OK的： 123456789101112131415new int[] &#123; 0, 1, 2, 3&#125;new int[] &#123; 0, 1, 2, 3&#125;new int[] &#123; 0, 1, 2, 3&#125;new int[] &#123;0, 1, 2, 3&#125; 非C风格的数组声明中括号是类型的一部分：String[] args， 而非 String args[]。 witch语句术语说明：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(case FOO:或default:)，后面跟着一条或多条语句。 缩进与其它块状结构一致，switch块中的内容缩进为2个空格。每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。 Fall-through：注释在一个switch块内，每个语句组要么通过break, continue, return或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用&#x2F;&#x2F; fall through)。这个特殊的注释并不需要在最后一个语句组(一般是default)中出现。示例： 12345678910switch (input) &#123; case 1: case 2: prepareOneOrTwo(); // fall through case 3: handleOneTwoOrThree(); break; default: handleLargeNumber(input);&#125; default的情况要写出来每个switch语句都包含一个default语句组，即使它什么代码也不包含。 注解(Annotations)注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如： 1@Nullable public String getNameIfPresent() &#123; ... &#125; 例外：单个的注解可以和签名的第一行出现在同一行。例如：@Override public int hashCode() { … }应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：@Partial @Mock DataLoader loader;参数和局部变量注解没有特定规则。 注释块注释风格块注释与其周围的代码在同一缩进级别。它们可以是&#x2F;* … &#x2F;风格，也可以是&#x2F;&#x2F; …风格。对于多行的&#x2F; … &#x2F;注释，后续行必须从开始， 并且与前一行的*对齐。以下示例注释都是OK的。 1234567/** This is // And so /* Or you can \\* okay. // is this. \\* even do this. \\*/ 注释不要封闭在由星号或其它字符绘制的框架里。 Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用&#x2F;* … *&#x2F;。 Modifiers类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。public protected private abstract static final transient volatile synchronized native strictfp 命名约定对所有标识符都通用的规则标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式\\w+。 标识符类型的规则包名包名全部小写，连续的单词只是简单地连接起来，不使用下划线。采用反域名命名规则，全部使用小写字母。一级包名为com，二级包名为xx（可以是公司或则个人的随便），三级包名根据应用进行命名，四级包名为模块名或层级名。例如：com.machinsight.webthings 包名 此包中包含 com.xx.应用名称缩写.activity 页面用到的Activity类 (activitie层级名用户界面层) com.xx.应用名称缩写.base 基础共享的类 com.xx.应用名称缩写.adapter 页面用到的Adapter类 (适配器的类) com.xx.应用名称缩写.util 此包中包含：公共工具方法类（util模块名） com.xx.应用名称缩写.bean 下面可分：vo、po、dto 此包中包含：JavaBean类 com.xx.应用名称缩写.model 此包中包含：模型类 com.xx.应用名称缩写.db 数据库操作类 com.xx.应用名称缩写.view 或者 com.xx.应用名称缩写.widget,自定义的View类等 com.xx.应用名称缩写.service Service服务 com.xx.应用名称缩写.receiver BroadcastReceiver服务 注意：如果项目采用MVP，所有M、V、P抽取出来的接口都放置在相应模块的i包下，所有的实现都放置在相应模块的impl下 类名类名都以UpperCamelCase风格编写。 类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。名词，采用大驼峰命名法，尽量避免缩写，除非该缩写是众所周知的， 比如HTML,URL，如果类名称中包含单词缩写，则单词缩写的每个字母均应大写。 类 描述 例如 Activity类 Activity为后缀标识 欢迎页面类WelcomeActivity Adapter类 Adapter为后缀标识 新闻详情适配器 NewsDetailAdapter 解析类 Parser为后缀标识 首页解析类HomePosterParser 工具方法类 Util或Manager为后缀标识（与系统或第三方的Utils区分）或功能+Util 线程池管理类：ThreadPoolManager,日志工具类：LogUtil（Logger也可）,打印工具类：PrinterUtil 数据库类 以DBHelper后缀标识 新闻数据库：NewDBHelper Service类 以Service为后缀标识 时间服务TimeServiceBroadcast Receiver类 以Receiver为后缀标识 推送接收JPushReceiver ContentProvider 以Provider为后缀标识 自定义的共享基础类 以Base开头 BaseActivity,BaseFragment 测试类 命名以它要测试的类的名称开始，以Test结束。 例如：HashTest 或 HashIntegrationTest。 接口（interface） 命名规则与类一样采用大驼峰命名法，多以able或ible结尾 如interface Runnable ;interface Accessible。 注意：如果项目采用MVP，所有Model、View、Presenter的接口都以I为前缀，不加后缀，其他的接口采用上述命名规则。 方法名方法名都以 LowerCamelCase 风格编写。方法名通常是动词或动词短语。 方法 说明 initXX() 初始化相关方法,使用init为前缀标识，如初始化布局initView() isXX()&#x2F;checkXX() 方法返回值为boolean型的请使用is或check为前缀标识 getXX() 返回某个值的方法，使用get为前缀标识 displayXX()&#x2F;showXX() 弹出提示框和提示信息，使用display&#x2F;show为前缀标识 handleXX() 对数据进行处理的方法，尽量使用handle为前缀标识 saveXX() 与保存数据相关的，使用save为前缀标识 resetXX() 对数据重组的，使用reset前缀标识 removeXXX() 移除控件或数据相关的 clearXX() 清除数据相关的 drawXXX() 绘制数据或效果相关的，使用draw前缀标识 下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：test_，例如testPop_emptyStack。并不存在唯一正确的方式来命名测试方法。 常量名常量名命名模式为CONSTANT_CASE，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时，考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。 12345678910111213// Constantsstatic final int NUMBER = 5;static final ImmutableListNAMES = ImmutableList.of(&quot;Ed&quot;, &quot;Ann&quot;);static final Joiner COMMA_JOINER = Joiner.on(&#x27;,&#x27;); // because Joiner is immutablestatic final SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;enum SomeEnum &#123; ENUM_CONSTANT &#125;// Not constantsstatic String nonFinal = &quot;non-final&quot;;final String nonStatic = &quot;non-static&quot;;static final SetmutableCollection = new HashSet();static final ImmutableSetmutableElements = ImmutableSet.of(mutable);static final Logger logger = Logger.getLogger(MyClass.getName());static final String[] nonEmptyArray = &#123;&quot;these&quot;, &quot;can&quot;, &quot;change&quot;&#125;; 这些名字通常是名词或名词短语。 非常量字段名非常量字段名以LowerCamelCase风格的基础上改造为如下风格：基本结构为scopeVariableNameType，scope：范围非公有，非静态字段命名以m开头。静态字段命名以s开头。公有非静态字段命名以p开头。公有静态字段（全局变量）命名以g开头。public static final 字段(常量) 全部大写，并用下划线连起来。例子： 123456789public class MyClass &#123; public static final int SOME_CONSTANT = 42; public int pField; private static MyClass sSingleton; int mPackagePrivate; private int mPrivate; protected int mProtected; public static int gField;&#125; 使用1字符前缀来表示作用范围，1个字符的前缀必须小写，前缀后面是由表意性强的一个单词或多个单词组成的名字，而且每个单词的首写字母大写，其它字母小写，这样保证了对变量名能够进行正确的断句。Type：类型考虑到Android中使用很多UI控件，为避免控件和普通成员变量混淆以及更好达意，所有用来表示控件的成员变量统一加上控件缩写作为后缀（文末附有缩写表）。对于普通变量一般不添加类型后缀，如果统一添加类型后缀，请参考文末的缩写表。用统一的量词通过在结尾处放置一个量词，就可创建更加统一的变量，它们更容易理解，也更容易搜索。 注意：如果项目中使用ButterKnife，则不添加m前缀，以LowerCamelCase风格命名。 例如，请使用 mCustomerStrFirst 和 mCustomerStrLast，而不要使用mFirstCustomerStr和mLastCustomerStr。量词列表：量词后缀说明First 一组变量中的第一个Last 一组变量中的最后一个Next 一组变量中的下一个变量Prev 一组变量中的上一个Cur 一组变量中的当前变量。 说明：集合添加如下后缀：List、Map、Set数组添加如下后缀：Arr 注意：所有的VO（值对象）统一采用标准的lowerCamelCase风格编写，所有的DTO（数据传输对象）就按照接口文档中定义的字段名编写。 参数名参数名以LowerCamelCase风格编写 局部变量名局部变量名以LowerCamelCase风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。临时变量临时变量通常被取名为i，j，k，m和n，它们一般用于整型；c，d，e，它们一般用于字符型。 如： for (int i &#x3D; 0; i &lt; len ; i++)，并且它和第一个单词间没有空格。 类型变量名类型变量可用以下两种风格之一进行命名： 单个的大写字母，后面可以跟一个数字(如：E,T,X,T2)。以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT,FooBarT)。 资源文件命名规范1. 资源布局文件（XML文件（layout布局文件））：全部小写，采用下划线命名法 contentview 命名必须以全部单词小写，单词间以下划线分割，使用名词或名词词组。所有Activity或Fragment的contentView必须与其类名对应，对应规则为：将所有字母都转为小写，将类型和功能调换（也就是后缀变前缀）。例如：activity_main.xml Dialog命名：dialog_描述.xml例如：dialog_hint.xml PopupWindow命名：ppw_描述.xml例如：ppw_info.xml 列表项命名：item_描述.xml例如：item_city.xml 包含项命名：模块_(位置)描述.xml例如：activity_main_head.xml、activity_main_bottom.xml注意：通用的包含项命名采用：项目名称缩写_描述.xml例如：xxxx_title.xml 2. 资源文件（图片drawable文件夹下）：全部小写，采用下划线命名法，加前缀区分命名模式：可加后缀 _small 表示小图, _big 表示大图，逻辑名称可由多个单词加下划线组成，采用以下规则： 用途_模块名_逻辑名称 用途_模块名_颜色 用途_逻辑名称 用途_颜色说明：用途也指控件类型（具体见UI控件缩写表）例如：btn_main_home.png按键divider_maket_white.png 分割线ic_edit.png 图标bg_main.png 背景btn_red.png 红色按键btn_red_big.png 红色大按键ic_head_small.png 小头像bg_input.png输入框背景divider_white.png白色分割线如果有多种形态如按钮等除外如 btn_xx.xml（selector） 名称 功能 btn_xx 按钮图片使用btn_整体效果（selector） btn_xx_pressed 按钮图片使用btn_点击时候效果 btn_xx_normal 按钮图片使用btn_正常情况效果 btn_xx_focused state_focused聚焦效果 btn_xx_disabled state_enabled (false)不可用效果 btn_xx_checked state_checked选中效果 btn_xx_selected state_selected选中效果 btn_xx_hovered state_hovered悬停效果 btn_xx_checkable state_checkable可选效果 btn_xx_activated state_activated激活的 btn_xx_windowfocused state_window_focused bg_head 背景图片使用bg_功能_说明 def_search_cell 默认图片使用def_功能_说明 ic_more_help 图标图片使用ic_功能_说明 seg_list_line 具有分隔特征的图片使用seg_功能_说明 sel_ok 选择图标使用sel_功能_说明 注意：使用AndroidStudio的插件SelectorChapek可以快速生成selector，前提是命名要规范。 3. 动画文件（anim文件夹下）：全部小写，采用下划线命名法，加前缀区分。具体动画采用以下规则：模块名_逻辑名称逻辑名称refresh_progress.xmlmarket_cart_add.xmlmarket_cart_remove.xml普通的tween动画采用如下表格中的命名方式&#x2F;&#x2F; 前面为动画的类型，后面为方向 动画命名例子 规范写法 fade_in 淡入 fade_out 淡出 push_down_in 从下方推入 push_down_out 从下方推出 push_left 推向左方 slide_in_from_top 从头部滑动进入 zoom_enter 变形进入 slide_in 滑动进入 shrink_to_middle 中间缩小 4. values中name命名 类别 命名 示例 strings strings的name命名使用下划线命名法，采用以下规则：模块名+逻辑名称 main_menu_about 主菜单按键文字friend_title好友模块标题栏friend_dialog_del好友删除提示login_check_email登录验证dialog_title 弹出框标题button_ok确认键 loading加载文字 colors colors的name命名使用下划线命名法，采用以下规则：模块名+逻辑名称 颜色 friend_info_bgfriend_bgtransparent gray styles styles的name命名使用Camel命名法，采用以下规则：模块名+逻辑名称 main_tabBottom 5. layout中的id命名命名模式为：view缩写_view的逻辑名称使用 AndroidStudio 的插件 ButterKnife Zelezny，生成注解非常方便。 编程实践@Override：能用则用只要是合法的，就把@Override注解给用上。 捕获的异常：不能忽视除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个 AssertionError 重新抛出。)如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。 1234567try &#123; int i = Integer.parseInt(response); return handleNumericResponse();&#125; catch (NumberFormatException ok) &#123; // it&#x27;s not numeric; that&#x27;s fine, just continue&#125;return handleTextResponse(response); 例外：在测试中，如果一个捕获的异常被命名为expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常，因此在这里就没有必要加注释。 12345try &#123; emptyStack.pop(); fail();&#125; catch (NoSuchElementException expected) &#123;&#125; 静态成员：使用类进行调用使用类名调用静态的类成员，而不是具体某个对象或表达式。 1234Foo aFoo = ...;Foo.aStaticMethod(); // goodaFoo.aStaticMethod(); // badsomethingThatYieldsAFoo().aStaticMethod(); // very bad Finalizers: 禁用极少会去重载Object.finalize。 Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解Effective Java第7条款：”Avoid Finalizers”，然后不要使用它。 Javadoc格式一般形式Javadoc块的基本格式如下所示： 12345/*** Multiple lines of Javadoc text are written here,* wrapped normally...*/public int method(String p1) &#123; ... &#125; 或者是以下单行形式： 1/** An especially short bit of Javadoc. */ 基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。 段落空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。除了第一个段落，每个段落第一个单词前都有标签，并且它和第一个单词间没有空格。 Javadoc标记标准的Javadoc标记按以下顺序出现：@param, @return, @throws, @deprecated,前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。 摘要片段##每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以A {@code Foo} is a…或This method returns…开头,它也不会是一个完整的祈使句，如Save the record…。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。 Tip：一个常见的错误是把简单的Javadoc写成 1/** @return the customer ID */ 这是不正确的。它应该写成 1/** Returns the customer ID. */ 哪里需要使用Javadoc至少在每个public类及它的每个public和protected成员处使用Javadoc，以下是一些例外： 例外：不言自明的方法对于简单明显的方法如getFoo，Javadoc是可选的(即，是可以不写的)。这种情况下除了写”Returns the foo”，确实也没有什么值得写了。单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。 Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名getCanonicalName， 就不应该忽视文档说明，因为读者很可能不知道词语canonical name指的是什么。 例外：重载如果一个方法重载了超类中的方法，那么Javadoc并非必需的。 可选的Javadoc对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为，那么这个注释应该写成Javadoc，这样更统一更友好。 附录： 表1 UI控件缩写表 控件 缩写 例子 LinearLayout ll llFriend或者mFriendLL RelativeLayout rl rlMessage或mMessageRL FrameLayout fl flCart或mCartFL TableLayout tl tlTab或mTabTL Button btn btnHome或mHomeBtn ImageButton ibtn btnPlay或mPlayIBtn TextView tv tvName或mNameTV EditText et etName或mNameET ListView lv lvCart或mCartLV ImageView iv ivHead或mHeadIV GridView gv gvPhoto或mPhotoGV 表2 常见的英文单词缩写: 名称 缩写 icon ic （主要用在app的图标） color cl（主要用于颜色值） divider di（主要用于分隔线，不仅包括Listview中的divider，还包括普通布局中的线） selector sl（主要用于某一view多种状态，不仅包括Listview中的selector，还包括按钮的selector） average avg background bg（主要用于布局和子布局的背景） buffer buf control ctrl delete del document doc error err escape esc increment inc infomation info initial init image img Internationalization I18N length len library lib message msg password pwd position pos server srv string str temp tmp window wnd(win) 程序中使用单词缩写原则：不要用缩写，除非该缩写是约定俗成的。","categories":[],"tags":[{"name":"android学习","slug":"android学习","permalink":"http://wongsuechang.github.io/tags/android%E5%AD%A6%E4%B9%A0/"},{"name":"app开发","slug":"app开发","permalink":"http://wongsuechang.github.io/tags/app%E5%BC%80%E5%8F%91/"}],"keywords":[]},{"title":"移动端开发方案对比","slug":"移动端开发方案对比","date":"2021-05-07T03:51:05.000Z","updated":"2021-08-01T00:32:16.000Z","comments":true,"path":"2021/05/07/移动端开发方案对比/","link":"","permalink":"http://wongsuechang.github.io/2021/05/07/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94/","excerpt":"","text":"传统移动端开发&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;传统的app的开发就是指原生开发，需要iOS工程师和Android工程师各自进行，iOS开发一份，Android开发一份，iOS使用的是Objective-C或者是Swift，Android使用的是Java或者是Kotlin。 App原生开发原生开发的优缺点 优点： 性能稳定，使用流畅，整体用户体验最佳 可支持离线使用 App质量和安全性有保证 开发兼容性好 功能齐全，可使用手机所有硬件 缺点： 开发以及维护成本高 开发周期长 获得新版本必须重新下载应用 内容限制（App Store上架限制） 适用场景&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;适用于跟系统高度耦合、追求性能的场景。 未来前景&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;由于目前已有的各种跨平台都存在缺陷、不够成熟，加上原生开发在性能上的优势，原生开发暂时还是主流方式。 移动端跨平台演进 跨平台技术演进 Web App (HTML5）开发&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;Web App 是指基于 Web 的应用，运行于网络和标准浏览器上，相当于一个网页然后加一个 App 的壳。Web技术本身需要浏览器的支持才能进行展示和用户交互，因此主要用到的技术是HTML5、Java、CSS等。 Web App开发优缺点 优点： 支持设备范围广，可以跨平台 开发成本低，周期短 无需用户手动更新 缺点： 无法使用手机硬件和本地存储 对网络要求高，无法离线使用 反应速度慢，流畅性较差 图片和动画支持不高，影响用户使用体验 适用场景&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;适用于快速试错，需要及时更新同时对性能和流畅度不做要求的场景，或者纯展示页面。 未来前景&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;动态发布、快速试错和不受限于平台，还是具有存在意义的。 混合App（原生+H5）开发&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;混合开发（Hybrid App开发），通常由“HTML5云网站+App应用客户端”两部份构成。混合开发也比较好理解，就是H5与原生开发的结合，主要是用js和原生技术相互调用，可以初步实现跨平台使用的效果，现在我们日常使用当中有很多App都是通过这种方式实现的。 混合开发优缺点 优点： 原生 + H5开发，可兼顾性能和流畅度 开发成本相对较低，开发周期比原生开发短 可通过JSBridge调用原生API，访问使用手机硬件 缺点： 依赖WebView，具有不稳定性 优化难度不低，需要Web前端、Android开发以及iOS开发团队配合 适用场景&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;适用于业务场景不复杂、需要动态发布的场景。 未来前景&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;Hybrid App 虽然开发效率高，可以跨平台，但是 Hybrid 体验比不上原生，对于需要快速试错、快速占领市场的团队来说，兼顾原生App和Web App的优缺点，可作为替代原生的方案之一。 特别说明，关于更新部分，目前Android可集成成熟的热更新方案（Google Play除外）；iOS因为App Store审核机制，需要确认热更新方案能否可用。 语言编译转换-Xamarin&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;Xamarin 是一个开放源代码平台，用于通过 .NET 构建适用于 iOS、Android 和 Windows 的新式高性能应用程序。 Xamarin 是一个抽象层，可管理共享代码与基础平台代码的通信。 Xamarin 在提供便利（如内存分配和垃圾回收）的托管环境中运行。 xamarin架构 &amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;Xamarin.Android 应用程序从 C# 编译为中间语言 (IL)，随后在启动应用程序时，再实时编译 (JIT)为本机程序集。 Xamarin.Android 应用程序在 Mono 执行环境中与 Android 运行时 (ART) 虚拟机并行运行。 Xamarin 向 Android. 和 Java. 命名空间提供 .NET 绑定。&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;Xamarin.iOS 应用程序完全预先 (AOT) 地从 C# 编译为本机 ARM 程序集代码。 Xamarin 使用选择器和注册器（共同称为“绑定”），使 Objective-C 和 C# 可以进行通信。 Xamarin优缺点 优点： 性能接近原生 Xamarin.Forms代码复用高达94% 强大的企业支持 完整的开发生态系统 缺点： 国内开发文档欠缺 第三方SDK的引用相对复杂 Xamarin社区不完善 不适用于重图形应用程序 未来前景&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;由于市场占有率极低，不推荐使用。 原生渲染React Native&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;React Native是Facebook公司于2015年4月开源的跨平台移动应用开发框架，它是Facebook早先开源的React框架在原生移动应用平台上的衍生产物，目前主要支持iOS和Android两大平台。&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;React Native使用JavaScript来编写应用程序，然后调用原生组件执行页面渲染操作，在提高了开发效率的同时又保留了原生的用户体验。&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;作为一个跨平台技术框架，RN从上到下可以分为Javascript层、C++层和Native层。其中，C++层主要用于实现动态连结库(.so)，作为中间适配层桥接，实现js端与原生端的双向通信交互。 RN三层架构 &amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;在RN的三层架构中，最核心的就是中间的C++层，C++层最核心的功能就是封装JavaScriptCore，用于执行对js的解析。同时，原生端提供的各种Native Module（如网络请求，ViewGroup控件模块）和JS端提供的各种JS Module（如JS EventEmiter模块）都会在C++实现的so文件中保存起来，最终通过C++层中的保存的映射实现两端的交互。 RN优缺点 优点： 支持热更新 运行流畅 在Javascript和React的基础上获得完全一致的开发体验 仅需学习一次，编写任何平台（Learn once, write anywhere） 可依赖的第三方库较多 缺点： 与原生应用相比，多了一层JS解析，渲染慢一些 在Android和iOS两端，部分控件不一致 对复杂UI不太友好 对开发者要求高，除了本身JS的了解，还必须熟悉原生开发 需要维护两套代码，代码重用率在70%左右 适用场景&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;适合业务场景不复杂、页面简单的小项目。 Weex&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;WEEX是由阿里巴巴研发的一套移动跨平台技术框架，最初是为了解决移动开发过程中频繁发版和多端研发的问题而开发的，目前已交由apache托管。&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;作为一套前端跨平台技术框架，Weex建立了一套源码转换以及Native与Js通信的机制。Weex表面上是一个客户端框架，但实际上它串联起了从本地开发、云端部署到分发的整个链路。&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;具体来说，在开发阶段编写一个.we文件，然后使用Weex提供的weex-toolkit转换工具将.we文件转换为JS bundle，并将生成的JS bundle上传部署到云端，最后通过网络请求或预下发的方式加载至用户的移动应用客户端。当集成了Weex SDK的客户端接收到JS bundle文件后，调用本地的JavaScript引擎执行环境执行相应的JS bundle，并将执行过程中产生的各种命令发送到native端进行界面渲染、数据存储、网络通信以及用户交互响应。 Weex架构 &amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;Weex框架中最核心的部分就是JavaScript Runtime。具体来说，当需要执行渲染操作时，在iOS环境下选择基于JavaScriptCore内核的iOS系统提供的JSContext，在Android环境下使用基于JavaScriptCore内核的JavaScript引擎。 Weex优缺点 优点： 入门简单，前端和移动开发易上手 更轻量，体积小巧 有良好的扩展性，比较好扩展新的 Component 和 Module 缺点： 缺少页面跳转动画 现存bug较多 社区不成熟，第三方库较少 离不开原生开发 适用场景&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;适用于电商类App、业务场景不复杂、需要动态更新的场景，或者一些单页面。 2.5 自渲染-Flutter&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;Flutter是谷歌公司开源的移动跨平台框架，其历史最早可以追溯到2015年的Sky项目，该项目可以同时运行在Android、iOS和Fuchsia等包含Dart虚拟机的平台上，并且性能无限接近原生平台。&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;与 react native 和 weex 的通过 Javascript 开发不同,Flutter使用C、C ++、Dart和Skia（2D渲染引擎）构建；旨在帮助开发人员轻松实现恒定的60fps。 Flutter架构 &amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;Flutter 主要分为 Framework 和 Engine，我们基于Framework 开发App，运行在 Engine 上。Engine 是 Flutter 的独立虚拟机，由它适配和提供跨平台支持&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;得益于 Engine 层，Flutter 甚至不使用移动平台的原生控件， 而是使用自己 Engine 来绘制 Widget （Flutter的显示单元），而 Dart 代码都是通过 AOT 编译为平台的原生代码，所以 Flutter 可以 直接与平台通信，不需要JS引擎的桥接。同时 Flutter 唯一要求系统提供的是 canvas，以实现UI的绘制。 Flutter优缺点 优点： 一套代码搞定iOS和Android应用 理论上在跨平台方案上性能最佳，很接近原生 UI跨平台稳定 代码量大大减少 缺点： Dart属于小众语言，需要重新学习 市场占有率低，第三方库较少 离不开原生开发 适用场景&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;适用于跟系统交互少、页面不太复杂的场景 总结偏传统开发方案对比 原生 Web Hybrid 适用场景 1)偏操作互动多的工具类应用2)需要访问特定的原生API3)对应用流畅度和性能有要求 1) 作为对非核心业务在移动端的入口补足2)作为用户轻量低频使用的体验增强 1)原生应用的适用场景2)需要频繁小幅度更新 开发语言 native语言 web开发语言 native+web开发语言 开发成本 高 低 中 体验 优 差 优 维护更新 复杂 简单 一般 升级灵活 低,一般通过应用商店升级 高 中,涉及native部分需要通过应用商店升级 资源存储 本地 服务器 本地+服务器 原生渲染与自渲染 React Native Weex Flutter 平台实现 JavaScript JavaScript 无桥接，原生编码 引擎 JSCore JS V8 Flutter engine 核心语言 React Vue Dart bundle文件大小 默认单一，较大 较小，多页面多文件 不需要 上手难度 较难 容易 一般 框架程度 较重 轻 重 特点 适合开发整体App 适合单页面 适合开发整体App 支持 社区活跃，第三方库较多 社区不成熟，第三方库较少 发布不久，第三方库较少 平台 Android&amp;iOS web、Android&amp;iOS Android&amp;iOS（不止于此） issues&#x2F;open(截至2021.5.6) 21246&#x2F;1343 940&#x2F;231 53985&#x2F;8959","categories":[],"tags":[{"name":"app开发","slug":"app开发","permalink":"http://wongsuechang.github.io/tags/app%E5%BC%80%E5%8F%91/"}],"keywords":[]},{"title":"美团配送数据治理实践","slug":"美团配送数据治理实践","date":"2020-03-23T07:59:09.000Z","updated":"2020-06-10T20:10:34.000Z","comments":true,"path":"2020/03/23/美团配送数据治理实践/","link":"","permalink":"http://wongsuechang.github.io/2020/03/23/%E7%BE%8E%E5%9B%A2%E9%85%8D%E9%80%81%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"作者:王鹏，2016 年加入美团点评，目前在配送事业部数据团队负责众包业务数据建设、数据治理和系统化相关工作。家豪，2018 年加入美团点评，目前在配送事业部数据团队负责众包业务数据建设、数据治理和系统化相关工作。 背景 大数据时代的到来，让越来越多的企业看到了数据资产的价值。将数据视为企业的重要资产，已经成为业界的一种共识，企业也在快速探索应用场景和商业模式，并开始建设技术平台。但这里要特别强调一下，如果在大数据“拼图”中遗忘了数据治理，可能再多的技术投入也是一种徒劳。因为没有数据治理这一环节，其带来后果往往是：随处可见的数据不统一，难以提升的数据质量，难以完成的模型梳理，难以保障的数据安全等等，源源不断的基础性数据问题会进一步产生，进而导致数据建设难以真正发挥其商业价值。 因此，消除数据的不一致性，建立规范的数据标准，提高数据治理能力，实现数据安全共享，并能够将数据作为企业的宝贵资产应用于业务、管理、战略决策中，发挥数据资产价值变得尤为迫切和重要，数据治理呼之欲出。本文将介绍美团配送技术团队在数据治理方面的一些探索和实践，希望能够对大家有所启发和帮助。 如何理解数据治理 数据治理，从严格的定义来讲是对组织的大数据管理并利用其进行评估、指导和监督的体系框架。企业通过制定战略方针、建立组织架构、明确职责分工等，实现数据的风险可控、安全合规、绩效提升和价值创造，并提供创新的大数据服务。从个人实践的层面来讲，数据治理是对存量数据治理和增量数据管控的一个过程，对存量数据实现由乱到治、建章立制，对增量数据实现严格把控、行不逾矩的约束。 数据治理本身并不是目的，它只是实现组织战略目标的一个手段而已。从组织职能和体量大小方面来看，不同类型组织的数据治理目标大不相同，而基于目前美团配送数据团队所处的组织职能和发展阶段来说，我们希望通过数据治理解决数据生产、管理和使用过程中遇到的问题，完善已有的生产管理流程规范，保障数据安全和数据一致性，从而促进数据在组织内无障碍地进行共享。 要达成的目标何时进行数据治理 找准数据治理的切入点，是关乎数据治理成败的关键。很多同学会问，如果将数仓建设分为数仓雏形阶段、数仓迭代阶段和能力沉淀阶段，数据治理应该在哪个阶段切入为宜呢？其实，我们不该把数据治理看作是一个阶段性的项目，它应该是一个贯彻数据建设各阶段的长期工程，只是在不同阶段根据业务特点和技术特点其覆盖的范围和关注的目标有所不同而已。 在数仓雏形阶段，也就是美团配送业务刚成立时，在该阶段中业务有两个特点：第一，重规模、快扩张；第二，业务变化快，数据需求多。为了快速响应业务的需求，并能够保障数据交付结果的准确性，我们主要进行技术规范和指标口径的治理，在规范治理方面，通过制定一系列研发规范来保障研发质量，并在实际建模过程中不断迭代和完善我们的研发质量。在指标治理方面，我们对存量指标口径进行梳理，从而确保指标口径对外输出一致。 在数仓迭代阶段，我们希望通过架构治理改变前期开发的“烟囱式”模型，消除冗余，提升数据一致性。并且随着数仓中管理的数据越多，数据安全和成本问题也变得越发重要。所以在该阶段，我们在产研层面逐步开展架构治理、资源治理和安全治理。在架构治理方面，我们明确了数仓中各层和各主题的职责和边界，构建一致的基础数据核心模型，并制定一系列的指标定义规范来确保指标的清晰定义，并基于业务迭代来不断完善和迭代相应的模型和规范。在资源治理方面，我们通过对不同层级的数据采用不同生命周期管理策略，确保用最少的存储成本来满足最大的业务需求。在安全治理方面，我们通过制定一系列的数据安全规范来确保数据的使用安全。 在能力沉淀阶段，我们基于前两个阶段所做的业务和技术沉淀，将前期一系列规范形成标准，从业务到产研，自上而下地推动数据治理，并通过建立相应的组织、流程和制度来保障标准在该阶段的全面落地实施，并通过建设数据治理平台来辅助更高质量地执行标准。 如何开展数据治理 从大的阶段来看，数据治理主要分为存量数据“由乱到治”的阶段，以及增量数据严格按照规章制度实施确保“行不逾矩”的运营阶段。在“由乱到治”的过程中，我们需要沉淀出规章制度、标准规范，以及辅以规章制度标准规范实施的工具和组织。在增量数据的运营阶段，我们主要靠对应的组织确保规章制度的落实，通过审计定期考察实施效果，并在长期的运营中不断完善规章制度。在实现存量数据“由乱到治”的阶段，我们主要采取了“两步走”策略，具体执行策略如下所示。 定标准，提质量 第一步，主要围绕着业务标准、技术标准、数据安全标准和资源管理标准进行展开。通过业务标准，指导一线团队完成指标的规范定义，最终达成业务对指标认知一致性这一目标；然后通过技术标准来指导研发同学规范建模，从技术层面解决模型扩展性差、冗余多等问题并保障数据一致性；通过安全标准来指导我们加强数据的安全管控，确保数据拿不走、走不脱，针对敏感数据，用户看不懂；通过资源管理标准的制定，帮助我们在事前做好资源预算，在事中做好资源管理，在事后做好账单管理。 业务标准 业务标准主要是指标的管理和运营标准，我们主要解决三个问题：指标由谁来定义，指标该如何定义，指标该如何运营。基于这三个问题，我们同时提出了三条原则：• 业务团队负责指标的定义。• 产研商分负责给出指标定义标准和辅助工具，辅助业务团队完成指标的规范定义，达成指标认知一致性这一目标。• 最后由指标管理委员会负责指标的管理与运营，保障指标从创建、审核、上线以及到最后消亡的整个生命周期的运营。 为统一指标的定义，我们将指标分为原子指标、衍生指标和派生指标，原子指标通过限定条件和时间的限定生成衍生指标。衍生指标间的“四则混合运算”构成了派生指标。我们不但制定了指标的标准定义，还对其做了准确的资产归属，一个指标出自一个具体的业务过程，一个业务过程归属于不同的数据域，多个数据域构成了美团配送业务线下的分析场景，如下图所示： 指标定义标准 技术标准 这里所说的技术标准，主要是针对数据 RD 提出的建模标准和数据生产规范，通过建模标准来明确数仓分层架构，并清晰定义每一层的边界与职责，采用维度建模的设计理念。我们的整个仓库架构分为四层：操作层、基础事实层、中间层和应用层，并在每一层同步制定对应的建模规范，如下图所示： 数仓架构以及建模标准 除了建模标准外，我们还制定了涵盖从生产到运维环节的生产规范以保障模型的质量，主要包括上线前的模型评审、生产过程中的完成元数据配置、DQC、SLA 和生命周期设置以及上线后的日常运维机制等等。尤其针对元数据管理和生命周期管理，我们分别制定了仓库每一层元数据维护规范和生命周期管理规范，其中元数据管理规范，是依据数仓各层级中各种类型表的建模标准来制定，需要做到规范命名，明确数据归属，并打通业务元数据和技术元数据之间的关系。而生命周期管理规范，是依据配送业务特点和数仓各层级现状来制定的，如下表所示： 仓库各层元数据管理标准 仓库各层生命周期管理策略 安全标准 围绕数据安全标准，首先要有数据的分级、分类标准，确保数据在上线前有着准确的密级。第二，针对数据使用方，要有明确的角色授权标准，通过分级分类和角色授权，来保障重要数据拿不走。第三，针对敏感数据，要有隐私管理标准，保障敏感数据的安全存储，即使未授权用户绕过权限管理拿到敏感数据，也要确保其看不懂。第四，通过制定审计标准，为后续的审计提供审计依据，确保数据走不脱。 安全标准建设 资源管理标准 在资源管理方面，配送技术工程部已经对资源管理涉及的内容进行了合理抽象和准确定义，抽象出租户、资源和项目组等概念。不管是后续的资源预算还是资源管理，我们都需要基于租户和项目组来进行运营，因此，对于业务团队而言，我们只需要将租户和项目组特定职能划分清楚，然后根据不同的职能归属我们的资产，并分配生产该资产所需要的资源。为了方便后续的运营，我们对每个租户和项目组分配确定了责任人，由责任人对运营结果负责。 对业务部门来说，资源管理的关键是对数据资产做清晰的分类，基于数据的分类划分不同的租户和项目组，将数据和租户、项目组实现一一映射。由于租户和项目组都有特定的责任人对其负责，因此，我们通过这种映射关系，不仅实现了资产的隔离，还实现了资产确权（项目组负责人同时对资产负责和运营）。我们整体将数据分为两大类，一是原始数据，包括流到数据中心的数据和日志中心的数据，针对流入数据中心的数据，根据其产生的方式不同，又进一步分为业务数据和流量数据。二是加工数据，对应着数据团队的仓库建设和其他团队的集市建设。基于上述的描述，针对资源管理，我们做了如下划分和确权： 资源划分与管理 重实施，保落实 第二步，落实第一步的标准，完成数据治理第一阶段的目标，实现存量数据“由乱到治”，并完成相应组织和工具的建设，为实现第二阶段“行不逾矩”这一目标提供工具和组织能力。在此过程中，主要分成三个方面的治理工作：第一，架构模型“由乱到治”的治理，消除模型冗余、跨层引用和链路过长等问题，在架构上保证模型的稳定性和数据一致性；第二，元数据“由乱到治”的治理，实现指标的标准定义、技术元数据的完整采集并建立指标与表、字段的映射关系，彻底解决指标认知一致性，以及用户在使用数据过程中的“找数难”等问题；第三，围绕着隐私安全和共享安全加强数据的安全管控来实现数据走不脱、拿不走，以及隐私数据看不懂这一目标。 架构治理 总结起来，架构方面的治理主要是解决两个问题：第一，模型的灵活性，避免需求变更和业务迭代对核心模型带来的冲击，让 RD 深陷无休止的需求迭代中；第二，数据一致性，消除因模型冗余、跨层引用等问题带来的数据一致性问题。 模型灵活性 配送解决的是效率、成本和体验三者之间的平衡问题，即在满足一定用户体验的条件下，如何提升骑手配送效率，服务更多的商家，以及如何管控骑手，降低配送成本。抽象到数据层面，基本上反映为上游包裹来源的变化、配送对外提供服务的变化以及对内业务管控的变化。为屏蔽业务迭代给核心模型带来的冲击，我们通过对外封装包裹属性和对内封装运单属性，抽象出包裹来源、提供服务、业务架构等一致性维度，任何业务迭代在数据层面只涉及维度的调整，大大降低了对核心模型冲击和“烟囱式”数据建设问题（新来一个业务，就拉起一个分支进行建设）。 包裹事实分配到运单明细构造单一运单模型 配送指标体系建设的一个重点就是要输出各组织层级的规模、体验和效率指标，实现对运力的有效管控，运力所属组织的层级关系会随业务的迭代而不断变化。为了适应这种变化，避免仅仅因增加维度带来中间层数据的重复建设，我们将组织层级维表由固定层级建模方式调整为桥接表的方式来自适配组织层级变化，从而实现了中间层模型可以自动适配组织层级的变化，能自动产生新维度的指标。如下图所示： 桥接表自适配组织层级灵活变动 在精细化分析的场景下，业务会有分时段、分距离段以及分价格段的数据分析诉求。我们以分时段为例，有晚高峰、午高峰、下午茶等不同的分时段，不同的业务方对同一个时段的定义口径不同，即不同的业务方会有不同的分时段策略。为解决该场景下的分析诉求，我们在事实表中消除退化维度，将原来封装到事实表的时段逻辑迁移到维度表中，并将事实表中的时间进行按特定的间隔进行刻度化作为维表中的主键，将该主键作为事实表的外键。这样，针对业务不同的时间策略需要，我们就可以在维表中进行配置，避免了重复调整事实表和反复刷数的问题。即通过将时间、价格、距离事实刻度化，实现灵活维度分析。如下图所示： 通过将时间刻度化，实现灵活分析 数据一致性 数据一致性得不到保障的一个根本原因，是在建模的过程中没有实现业务口径标签化，并将业务口径下沉到主题层。很多同学在基于需求进行开发时，为实现方便，将新指标口径通过“Case When”的方式在应用层和中间层进行封装开发，主题层建设不能随着业务的迭代不断完善，RD 在开发过程中会直接引用仓库的快照表在中间层或应用层完成需求开发。久而久之，就会造成数据复用性低下，相同指标的口径封装在不同的应用表来满足不同报表的需求，但随着应用的增多，很难保障相同指标在不用应用表封装逻辑的一致性，数据一致性难以得到保障，同时这种方式还带来两个严重后果：第一，跨层引用增多，数据复用性低下，造成计算和存储成本的浪费；第二，一旦指标口径发生变化，将是一个“灾难”，不仅影响评估是一个问题，而且涉及该指标的应用层逻辑调整对 RD 来说也是一个巨大的挑战。 治理前模型架构 因此，我们在“由乱到治”的治理过程中，以衍生事实的方式实现业务口径标签化，将业务逻辑下沉到主题层，消除跨层引用和模型冗余等问题，从技术层面保障数据一致性是该阶段架构治理的重点。我们在业务上，已经划分了严格的数据域和业务过程，在主题建设层面，将业务划分的数据域作为我们的主题，并基于业务过程进行维度建模，将属于该业务过程的指标口径封装在对应业务过程下的衍生事实中。 治理后模型架构 元数据治理 元数据治理主要解决三个问题：首先，通过建立相应的组织、流程和工具，推动业务标准的落地实施，实现指标的规范定义，消除指标认知的歧义；其次，基于业务现状和未来的演进方式，对业务模型进行抽象，制定清晰的主题、业务过程和分析方向，构建完备的技术元数据，对物理模型进行准确完善的描述，并打通技术元数据与业务元数据的关系，对物理模型进行完备的刻画；第三，通过元数据建设，为使用数据提效，解决“找数、理解数、评估”难题以及“取数、数据可视化”等难题。首先，为保障业务标准的顺利实施，实现业务对指标认知一致性这一目标。我们协同产研、商分、业务部门推动成立了度量衡委员会，并建立起指标运营机制，通过组织保障来实现指标运营按照规范的标准和流程实施。如下图所示： 指标注册流程 其次，基于配送业务的现状和未来演进方式，我们进行了高度的业务抽象，完成了主题、业务过程和分析方向等元数据内容的建设。配送即物流，通过线上系统和线下运营，我们将用户的配送需求和美团的运力进行有效的资源配置，实现高服务体验、低成本的配送服务。对外，我们将配送服务通过平台化的方式，提供给用户、商户和电商平台，以满足不同用户在不同业务场景下的配送需求。对内，我们通过不同的调度模式将运单池中的运单调度给合适的骑手来完成履约，平衡规模、成本和体验之间的关系。如下图所示： 配送业务模式抽象 基于以上的业务模式，我们划分了运单主题（对履约数据域下的数据进行构建，支撑规模和体验的数据分析需求）、调度主题（调度数据域下产生的数据，用于支撑调度策略的分析）、结算、评价、投诉、取消主题（用于支撑体验、成本数据分析需求）和管控主题（用于支撑运力奖惩、违规和招募分析需求）等各种主题，并在每个主题下划分对应的业务过程，在应用层制定分析方向的分析标签，通过对元数据内容的建设完成对业务的抽象，为物理模型的刻画准备了基础数据。 第三，元数据服务建设，我们打通了元数据从采集到构建再到应用的整条链路，为使用数据提效，解决“找数、理解数、评估”难题以及“取数、数据可视化”难题。在整个建设过程中，我们围绕着元数据采集、元模型构建、元数据服务以及最后的产品应用进行展开，整体架构如下图所示： 元数据建设架构图 元数据采集 元数据采集分为人工录入和自动抽取，通过人工录入的方式实现物理表的准确归属（包括该表属于仓库哪一层、对应的主题、业务过程、星型模型关系等）以及指标的采集，从而完成技术元数据和业务元数据的采集，通过自动抽取的方式完成生产元数据的采集和使用元数据的采集，主要包括：物理模型的依赖关系、存储占用、热度、等信息。 元模型构建 分为以物理表为核心的基础元模型构建，以及以血缘为中心的血缘元模型。基础元模型构建以物理表为中心，打通其与技术元数据（主题、业务过程、Schema）的关系，实现了物理表的清晰归属，打通其与生产元数据的关系，为其加上了物理表查询热度、资源消耗、查询密级等生产使用信息，打通其与指标、维度和应用的对应关系，为上层的取数应用建立了完备的元数据。血缘元模型以血缘为中心，不仅构建了从上游业务表到仓库离线表的物理血缘，而且打通了仓库离线表到下游对应报表的血缘，为后续的影响评估构建了完备的元数据基础。 元数据服务 统一元数据服务（OneService），主要提供两类元数据服务，提供查询表、指标、维度基本信息的基础元数据服务以及查询表级血缘、字段级血缘的血缘服务。 元数据应用 主要孵化出了三个产品，以“找数、理解数、影响评估”为应用场景的数据地图（Wherehows），以“取数、数据可视化”为应用场景的数据可视化（QuickSight），以及以管理审计为目的的管理审计报表。 安全治理 安全治理主要加强了敏感数据的安全治理和数据共享环节的安全治理。通过对隐私数据的安全治理，不仅要保证其在存储环节的不可见性，而且还要保证在其使用环节对用户进行双重鉴权，字段的密级鉴权和解密的密钥鉴权；通过对数据共享环节的安全治理，我们在数据分级分类的基础上，使数据的权限控制从表级权限控制扩展到行级权限控制。 敏感数据安全治理 敏感数据的安全治理，主要是解决敏感数据的存储安全和使用安全。离线场景下，敏感数据存储安全要解决两大挑战：• 确保仓库侧处理方案既要屏蔽上游业务系统变动带来的影响，又要屏蔽自身策略对下游 BI 系统的影响。• 要避免敏感数据在整个加工链路中的扩散。 因此，为解决仓库处理方案与上游业务系统和下游 BI 系统的解耦问题，我们在上游敏感数据落到 ODS 环节，确保落到 ODS 层的敏感数据必须是明文，为保障其安全，对 ODS 层的所有数据进行文件加密，但是在使用层面，对下游链路透明保障下游链路的正常生产，并限制 ODS 层数据权限的开放。 ODS 层数据只用于安全生产，通过此方案既屏蔽了上游处理方案对仓库的影响，又解决了敏感数据的安全问题。当数据从离开仓库时，在传输环节对敏感数据进行可逆操作，将敏感数据以明文的形式推入 BI 库，实现与下游 BI 系统的解耦。为解决敏感数据在整个生产链路的扩散，我们在快照层对敏感数据进行脱敏处理，从快照层开始消除敏感数据，为保障敏感数据的可逆性，将 ODS 层的敏感数据抽取到安全库中并进行加密存储，实现安全独立管理。具体执行如下图所示： 敏感数据安全治理 针对敏感数据的使用安全，我们通过对敏感字段的权限控制和对解密密钥的权限控制，来实现敏感数据使用安全这一目标。针对单独抽取的敏感数据，我们除了针对敏感数据设置其相应的密级确保敏感数据的权限管控外，还基于 “ 暗语 “ 的加密方式为每个项目组分配一个相同的密钥，并且将该密钥存放到与 Hadoop 集群集成的 KMS 进行管理（确保支撑离线计算的高并发），确保解密时实现密钥的权限管控。 共享环节安全治理 针对共享环节的安全治理，我们主要是在数据生产环节完成数据的分级分类和数据确权，在数据的使用环节完成数据的表级权限控制和行级权限控制。确保数据在使用环节规范的审批流转，权限开放以后的安全审计，保证数据走不脱。 首先，我们在生产环节 B3、B2、B1 层数据按照主题或实体 C 层数据按照应用方向进行逻辑划分，并设定资源的密级和权限负责人。特别地为实现 B3 层数据在查询环节可按照业务线进行权限管控这一目标（即行级鉴权），针对 B3 层数据，我们标记该数据需要在查询环节进行行级权限管控，标记使用行级鉴权所需的字段和该字段对应的枚举值。 其次，在使用环节，我们按照资产密级和使用人角色完成数据的审批流转，实现数据的安全共享。 第三，针对 B3 层数据，审计是否设置了行级权限管控。在数据开放时是否存在越权使用的情况，以及针对即将离职员工加强数据的使用审计，保证数据走不脱。在数据“由乱到治”的治理过程中，我们不仅实现了存量数据的“由乱到治”，并且在此过程中沉淀出了一系列的建模方法论、工具，并建立了相应的安全小组和指标运营组织。同时，我们为后续增量数据治理确保数据建设“行不逾矩”，提供了强有力的组织保障、稳定的辅助工具和严格的执行标准。在数据治理的第二阶段实现增量数据的“行不逾矩”的过程中，我们主要围绕大数据架构审计、大数据安全与隐私管理审计、大数据质量管理审计和大数据生命周期管理审计这四方面的工作展开，保障治理工作的持续进行，不断提高了组织的治理水平。 工具简介数据地图（Wherehows） 数据地图作为元数据应用的一个产品，聚焦于数据使用者的“找数”场景，实现检索数据和理解数据的“找数”诉求。我们通过对离线数据集和在线数据集的元数据刻画，满足了用户找数和理解数的诉求，通过血缘图谱，完成物理表到产品的血缘建设，消除用户人肉评估的痛苦。 离线数据场景 关键字检索和向导查询共同解决了“找数据”的问题：大部分的检索数据场景下，数据使用者都可以通过关键字检索来得到匹配结果。剩下的一小部分场景，例如，对于新人入职后如何了解整个数仓和指标的体系（数仓分几层，每层解决什么问题，都孵化出什么模型；整个指标、维度体系都是怎么分类，有哪些指标和维度），这部分场景可以使用向导查询功能。向导查询相当于分类查询，将表和指标按照业务过程进行分类，用户可以按照分类逐步找到想要的表或指标。 关键字检索找数据 向导查询找数据 我们打通了业务元数据和技术元数据之间的关系，提高了“找数据”的能力：通过“Wherehows”查找到指标后，不仅不可查看指标的业务定义，还能查看指标的技术实现逻辑，指标在哪些维度或维度组合中已经实现，并且能够在哪张表里找到这些维度，或维度组合的指标数据。反之，也可以知道在某个维度下已经实现了哪些指标，对应的指标在哪些表里。这些功能能让用户更加方便地找到想要的数据。 打通业务元和技术元 我们提供了较为完善的数据信息，帮助用户更好理解数据：对于表的信息，“Wherehows”除了提供表和字段的中英文名称、描述信息等基础信息外，为了帮助用户更好地理解表的建设思路，我们还提供了表的星型模型（可以关联的一致性维度及对应的维度表）、表的血缘关系等信息。 完善数据信息帮助理解数据 我们通过评论问答功能，帮助用户可以快速得到问题反馈：如果用户看了信息后还是感到有问题，“Wherehows”提供评论问答的功能，用户通过这个功能可以进行提问，会有相应的负责人进行回复。对于重复问反复问的问题，用户通过查看其它人的提问和回复就能找到答案。并且负责人还会定期的将问答信息沉淀到对应的元数据里，不断地对元数据进行补充和完善。 评论问答,快速反馈 业务数据场景 业务数据场景主要想解决的一个问题是，如何知道一个业务表（MySQL 表）有没有同步到数仓。如果没有同步，能够找谁进行同步。因为已经打通“业务表 -&gt; 数仓表 -&gt; 产品”三者之间的血缘关系，我们能够轻松解决业务数据场景的问题。 业务数据场景 生产评估场景 在日常数据生产工作中，我们经常需要对表进行影响评估、故障排查、链路分析等工作，这些工作如果靠纯人工去做，费时费力。但现在我们已经打通了“业务表 &#x2F; 字段 -&gt; 数仓表 &#x2F; 字段 -&gt; 产品”三者之间的血缘关系，就能够在 10 分钟内完成评估工作。对于不同的场景，血缘链路提供了两个便捷的功能：过滤和剪枝。例如，某个表逻辑需要修改，需要看影响哪些下游表或产品？应该要通知哪些 RD 和 PM？这种情况下，血缘工具直观地显示影响了哪些负责人和产品，以及这个表的下游链路。 生产评估场景 有些表的链路很长，整个血缘关系图很大，这样会导致用户定位信息或问题。所以血缘工具提供了剪枝的功能，对于没用的、不想看到的分支可以剪掉，从而让整个链路变得更加直观。 数据可视化（QuickSight） 聚焦于数据使用者“取数”场景，使用 QuickSight，用户可以不再关心数据的来源，不再担心数据的一致性，不再依赖 RD 的排期开发。通过所选即所得的方式，满足了用户对业务核心指标的二次加工、报表和取数诉求。首先，我们通过指标池、数据集等概念对离线生产的指标进行逻辑隔离，针对不同用户开发不同的数据集以达到权限控制的目的，如下图所示： 用户、指标池与数据集间的关系 其次，我们为用户提供一系列的组件，帮助用户基于为其开放的数据集实现指标的二次加工和数据可视化功能，满足其在不同业务场景下的取数和可视化应用。如下图所示： 指标加工组件01 指标加工组件02 总结与展望 经过三个阶段的治理工作，我们在各个方面都取得了较好的效果：• 在数据标准方面，我们制定了业务标准、技术标准、安全标准、资源管理标准，从而保障了数据生产、管理、使用合规。• 在数据架构方面，我们通过桥接表、时间刻度化、业务口径下沉等手段提升模型灵活性，并保障数据一致性，消除跨层引用和模型冗余等问题。• 在数据安全方面，我们加强了对敏感数据和数据共享环节的安全治理，保证数据拿不走、走不脱，隐私数据看不懂。• 在元数据建设方面，我们打通了从采集到构建再到应用的整条链路，并为数据使用人员提供数据地图、数据可视化等元数据应用产品，帮助他们解决了“找数”、“取数”、“影响评估”等难题。 未来，我们还会继续通过组织、规范、流程等手段持续对数据安全、资源利用、数据质量等各方面进行治理，并在数据易用性上下功夫，持续降低用户的数据使用成本。• 在数据架构方面，随着数据库技术的飞速进步，现在已经有很多数据库能够支持千万级乃至亿级数据的现算先用，我们也在尝试使用这些数据库帮助提升数据开发效率，改善数仓分层管理和应用支撑效率。• 在数据产品方面，我们将持续完善数据地图、数据可视化等数据应用产品，帮助用户快速探查、高效分析，真正发挥数据的业务价值。 原文链接：https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651751418&amp;idx=2&amp;sn=11f4d11b492c3390d99044a279ca69f2&amp;chksm=bd125ab78a65d3a159d6e722e87d650d1ba5745f0ff0dbbb11e3036983b75982dce2a9e6cdcb&amp;scene=27#wechat_redirect","categories":[],"tags":[{"name":"数据","slug":"数据","permalink":"http://wongsuechang.github.io/tags/%E6%95%B0%E6%8D%AE/"}],"keywords":[]},{"title":"阿里Sophix热更新从入门到应用","slug":"阿里Sophix热更新从入门到应用","date":"2019-09-24T09:59:49.000Z","updated":"2019-10-29T19:53:36.000Z","comments":true,"path":"2019/09/24/阿里Sophix热更新从入门到应用/","link":"","permalink":"http://wongsuechang.github.io/2019/09/24/%E9%98%BF%E9%87%8CSophix%E7%83%AD%E6%9B%B4%E6%96%B0%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BA%94%E7%94%A8/","excerpt":"","text":"1.引言&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;用户在某些情况下不愿意手动点击更新，同时产品提出公司App做到无感修复更新。综合考虑各大厂商热更新方案，倾向于阿里的Sophix方案，原因如下： 1. so文件替换更新 2. 资源文件替换 3. 尽量可以做到实时修复 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Sophix修复方案加分项： ①支持加密传输和签名校验； ②性能损耗低； ③接入开发成本低； ④价格合适。 image 2、集成准备2.1 android studio集成&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;gradle远程仓库依赖, 打开项目找到app的build.gradle文件，添加如下配置：&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;添加maven仓库地址： 12345repositories &#123; maven &#123; url &quot;http://maven.aliyun.com/nexus/content/repositories/releases&quot; &#125;&#125; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;添加gradle坐标版本依赖： 1compile &#x27;com.aliyun.ams:alicloud-android-hotfix:3.2.8&#x27; 注意：使用android studio打包生成apk时，要关闭instant run。 2.2 权限&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Sophix SDK使用到以下权限 123456&lt;! -- 网络权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&lt;! -- 外部存储读权限，调试工具加载本地补丁需要 --&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;READ_EXTERNAL_STORAGE权限属于Dangerous Permissions，仅调试工具获取外部补丁需要，不影响线上发布的补丁加载，调试时请自行做好android6.0以上的运行时权限获取。 2.3 AndroidManifest文件配置&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在 AndroidManifest.xml 中间的 application节点下添加如下配置： 123456789&lt;meta-dataandroid:name=&quot;com.taobao.android.hotfix.IDSECRET&quot;android:value=&quot;App ID&quot; /&gt;&lt;meta-dataandroid:name=&quot;com.taobao.android.hotfix.APPSECRET&quot;android:value=&quot;App Secret&quot; /&gt;&lt;meta-dataandroid:name=&quot;com.taobao.android.hotfix.RSASECRET&quot;android:value=&quot;RSA密钥&quot; /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;将上述value中的值分别改为通过平台HotFix服务申请得到的App Secret和RSA密钥，出于安全考虑，建议使用setSecretMetaData这个方法进行设置。另外，热修复暂不支持EMAS统一插件的json文件读取。 2.4 混淆配置1234567891011#基线包使用，生成mapping.txt-printmapping mapping.txt#生成的mapping.txt在app/build/outputs/mapping/release路径下，移动到/app路径下#修复后的项目使用，保证混淆结果一致#-applymapping mapping.txt#hotfix-keep class com.taobao.sophix.**&#123;*;&#125;-keep class com.ta.utdid2.device.**&#123;*;&#125;-dontwarn com.alibaba.sdk.android.utils.**#防止inline-dontoptimize 3 SDK接口使用说明3.1 接入范例&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initialize的调用应该尽可能的早，必须在Application.attachBaseContext()的最开始（在super.attachBaseContext之后，如果有Multidex，也需要在Multidex.install之后）进行SDK初始化操作，初始化之前不能用到其他自定义类，否则极有可能导致崩溃。而查询服务器是否有可用补丁的操作可以在后面的任意地方。不建议在Application.onCreate()中初始化，因为如果带有ContentProvider，就会使得Sophix初始化时机太迟从而引发问题。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;从app稳定性角度考虑，我们应采用稳健接入方式。原来的初始化方式虽然可以使用，但新方式可以提供更全面的功能修复支持。新的初始化方式带来如下有点：&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.初始化与应用原先业务代码完全隔离，使得原先真正的Application可以修复；&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2.减少了补丁预加载时间；&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;3.更完美地兼容Android 8.0以后版本。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;具体接入，需要用到以下这个类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.machinsight.dcollision;import android.app.Application;import android.content.Context;import android.support.annotation.Keep;import android.util.Log;import com.taobao.sophix.PatchStatus;import com.taobao.sophix.SophixApplication;import com.taobao.sophix.SophixEntry;import com.taobao.sophix.SophixManager;import com.taobao.sophix.listener.PatchLoadStatusListener;import com.my.pkg.MyRealApplication;/** * Sophix入口类，专门用于初始化Sophix，不应包含任何业务逻辑。 * 此类必须继承自SophixApplication，onCreate方法不需要实现。 * 此类不应与项目中的其他类有任何互相调用的逻辑，必须完全做到隔离。 * AndroidManifest中设置application为此类，而SophixEntry中设为原先Application类。 * 注意原先Application里不需要再重复初始化Sophix，并且需要避免混淆原先Application类。 * 如有其它自定义改造，请咨询官方后妥善处理。 */public class SophixStubApplication extends SophixApplication &#123; private final String TAG = &quot;SophixStubApplication&quot;; // 此处SophixEntry应指定真正的Application，并且保证RealApplicationStub类名不被混淆。 @Keep @SophixEntry(MyRealApplication.class) static class RealApplicationStub &#123;&#125; @Override protected void attachBaseContext(Context base) &#123; super.attachBaseContext(base);// 如果需要使用MultiDex，需要在此处调用。// MultiDex.install(this); initSophix(); &#125; private void initSophix() &#123; String appVersion = &quot;0.0.0&quot;; try &#123; appVersion = this.getPackageManager() .getPackageInfo(this.getPackageName(), 0) .versionName; &#125; catch (Exception e) &#123; &#125; final SophixManager instance = SophixManager.getInstance(); instance.setContext(this) .setAppVersion(appVersion) .setSecretMetaData(null, null, null) .setEnableDebug(true) .setEnableFullLog() .setPatchLoadStatusStub(new PatchLoadStatusListener() &#123; @Override public void onLoad(final int mode, final int code, final String info, final int handlePatchVersion) &#123; if (code == PatchStatus.CODE_LOAD_SUCCESS) &#123; Log.i(TAG, &quot;sophix load patch success!&quot;); &#125; else if (code == PatchStatus.CODE_LOAD_RELAUNCH) &#123; // 如果需要在后台重启，建议此处用SharePreference保存状态。 Log.i(TAG, &quot;sophix preload patch success. restart app to make effect.&quot;); &#125; &#125; &#125;).initialize(); &#125;&#125; 12// queryAndLoadNewPatch不可放在attachBaseContext 中，否则无网络权限，建议放在后面任意时刻，如onCreate中SophixManager.getInstance().queryAndLoadNewPatch(); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;其中关键一点： 123@Keep@SophixEntry(MyRealApplication.class)static class RealApplicationStub &#123;&#125; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SophixEntry应指定项目中原先真正的Application（原项目里application的android::name指定的），这里用MyRealApplication指代。并且保证RealApplicationStub类名不被混淆。而SophixStubApplication的类名和包名可以自行取名。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这里的Keep是android.support包中的类，目的是为了防止这个内部静态类的类名被混淆，因为sophix内部会反射获取这个类的SophixEntry。如果项目中没有依赖android.support的话，就需要在progurad里面手动指定RealApplicationStub不被混淆，详见下文。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;然后，在proguard文件里面需要加上下面内容： 12345-keepclassmembers class com.my.pkg.MyRealApplication &#123; public &lt;init&gt;();&#125;# 如果不使用android.support.annotation.Keep则需加上此行# -keep class com.my.pkg.SophixStubApplication$RealApplicationStub &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;目的是防止真正Application的构造方法被proguard混淆。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;最后，需要把AndroidManifest里面的application改为这个新增的SophixStubApplication类： 1234&lt;application android:name=&quot;com.my.pkg.SophixStubApplication&quot; ... ...&gt; ... ... 总结一下，过程一共有四个步骤：&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.把此SophixStubApplication入口类添加进项目中，所有Sophix相关初始化放在此类中。并且不应包含开发者的任何业务逻辑代码。若使用了MultiDex，也应在SophixStubApplication的initSophix之前添加，并且需要记得在原来的Application里面去除MultiDex，避免重复调用导致问题。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2.把RealApplicationStub的SophixEntry注解的内容改为自己原先真正的MyRealApplication类。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;3.混淆文件中确保某些内容不被混淆。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;4.AndroidManifest里面的application改为新增的SophixStubApplication入口类。 3.2 接口说明3.2.1 initialize方法 initialize(): &lt;必选&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;该方法主要做些必要的初始化工作以及如果本地有补丁的话会加载补丁, 但不会自动请求补丁。因此需要自行调用queryAndLoadNewPatch方法拉取补丁。这个方法调用需要尽可能的早, 必须在Application的attachBaseContext方法的最前面调用（在super.attachBaseContext之后，如果有Multidex，也需要在Multidex.install之后）, initialize()方法调用之前你需要先调用如下几个方法进行一些必要的参数设置, 方法调用说明如下: setContext(application): &lt;必选&gt; 传入入口Application即可 setAppVersion(appVersion): &lt;必选&gt; 应用的版本号 setSecretMetaData(idSecret, appSecret, rsaSecret): &lt;可选，推荐使用&gt; 三个Secret分别对应AndroidManifest里面的三个，可以不在AndroidManifest设置而是用此函数来设置Secret。放到代码里面进行设置可以自定义混淆代码，更加安全，此函数的设置会覆盖AndroidManifest里面的设置，如果对应的值设为null，默认会在使用AndroidManifest里面的。 setEnableDebug(isEnabled): &lt;可选&gt; isEnabled默认为false, 是否调试模式, 调试模式下会输出日志以及不进行补丁签名校验. 线下调试此参数可以设置为true, 查看日志过滤TAG:Sophix, 同时强制不对补丁进行签名校验, 所有就算补丁未签名或者签名失败也发现可以加载成功. 但是正式发布该参数必须为false, false会对补丁做签名校验, 否则就可能存在安全漏洞风险 setAesKey(aesKey): &lt;可选&gt; 用户自定义aes秘钥, 会对补丁包采用对称加密。这个参数值必须是16位数字或字母的组合，是和补丁工具设置里面AES Key保持完全一致, 补丁才能正确被解密进而加载。此时平台无感知这个秘钥, 所以不用担心阿里云移动平台会利用你们的补丁做一些非法的事情。 setPatchLoadStatusStub(new PatchLoadStatusListener()): &lt;可选&gt; 设置patch加载状态监听器, 该方法参数需要实现PatchLoadStatusListener接口, 接口说明见3.2.说明 setUnsupportedModel(modelName, sdkVersionInt):&lt;可选&gt; 把不支持的设备加入黑名单，加入后不会进行热修复。modelName为该机型上Build.MODEL的值，这个值也可以通过adb shell getprop | grep ro.product.model取得。sdkVersionInt就是该机型的Android版本，也就是Build.VERSION.SDK_INT，若设为0，则对应该机型所有安卓版本。目前控制台也可以直接设置机型黑名单，更加灵活。 3.2.2 queryAndLoadNewPatch方法&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;该方法主要用于查询服务器是否有新的可用补丁. SDK内部限制连续两次queryAndLoadNewPatch()方法调用不能短于3s, 否则的话就会报code:19的错误码. 如果查询到可用的话, 首先下载补丁到本地。 应用原本没有补丁, 那么如果当前应用的补丁是热补丁, 那么会立刻加载(不管是冷补丁还是热补丁). 如果当前应用的补丁是冷补丁, 那么需要重启生效. 应用已经存在一个补丁, 请求发现有新补丁后，本次不受影响。并且在下次启动时补丁文件删除, 下载并预加载新补丁。在下下次启动时应用新补丁。 补丁在后台发布之后, 并不会主动下行推送到客户端, 需要手动调用queryAndLoadNewPatch方法查询后台补丁是否可用. 只会下载补丁版本号比当前应用存在的补丁版本号高的补丁, 比如当前应用已经下载了补丁版本号为5的补丁, 那么只有后台发布的补丁版本号&gt;5才会重新下载. 同时1.4.0以上版本服务后台上线了“一键清除”补丁的功能, 所以如果后台点击了“一键清除”那么这个方法将会返回code:18的状态码. 此时本地补丁将会被强制清除, 同时不清除本地补丁版本号 3.2.3 killProcessSafely方法&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可以在PatchLoadStatusListener监听到CODE_LOAD_RELAUNCH后在合适的时机，调用此方法杀死进程。注意，不可以直接Process.killProcess(Process.myPid())来杀进程，这样会扰乱Sophix的内部状态。因此如果需要杀死进程，建议使用这个方法，它在内部做一些适当处理后才杀死本进程。 3.2.4 cleanPatches()方法&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;清空本地补丁，并且不再拉取被清空的版本的补丁。正常情况下不需要开发者自己调用，因为Sophix内部会判断对补丁引发崩溃的情况进行自动清空。 3.2.5 PatchLoadStatusListener接口&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;该接口需要自行实现并传入initialize方法中, 补丁加载状态会回调给该接口, 参数说明如下: mode: 无实际意义, 为了兼容老版本, 默认始终为0 code: 补丁加载状态码, 详情查看PatchStatus类说明 info: 补丁加载详细说明 handlePatchVersion: 当前处理的补丁版本号, 0:无 -1:本地补丁 其它:后台补丁常见状态码说明如下: 一个补丁的加载一般分为三个阶段: 查询&#x2F;预加载&#x2F;加载12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//兼容老版本的code说明 int CODE_LOAD_SUCCESS = 1;//加载阶段, 成功 int CODE_ERR_INBLACKLIST = 4;//加载阶段, 失败设备不支持 int CODE_REQ_NOUPDATE = 6;//查询阶段, 没有发布新补丁 int CODE_REQ_NOTNEWEST = 7;//查询阶段, 补丁不是最新的 int CODE_DOWNLOAD_SUCCESS = 9;//查询阶段, 补丁下载成功 int CODE_DOWNLOAD_BROKEN = 10;//查询阶段, 补丁文件损坏下载失败 int CODE_UNZIP_FAIL = 11;//查询阶段, 补丁解密失败 int CODE_LOAD_RELAUNCH = 12;//预加载阶段, 需要重启 int CODE_REQ_APPIDERR = 15;//查询阶段, appid异常 int CODE_REQ_SIGNERR = 16;//查询阶段, 签名异常 int CODE_REQ_UNAVAIABLE = 17;//查询阶段, 系统无效 int CODE_REQ_SYSTEMERR = 22;//查询阶段, 系统异常 int CODE_REQ_CLEARPATCH = 18;//查询阶段, 一键清除补丁 int CODE_PATCH_INVAILD = 20;//加载阶段, 补丁格式非法 //查询阶段的code说明 int CODE_QUERY_UNDEFINED = 31;//未定义异常 int CODE_QUERY_CONNECT = 32;//连接异常 int CODE_QUERY_STREAM = 33;//流异常 int CODE_QUERY_EMPTY = 34;//请求空异常 int CODE_QUERY_BROKEN = 35;//请求完整性校验失败异常 int CODE_QUERY_PARSE = 36;//请求解析异常 int CODE_QUERY_LACK = 37;//请求缺少必要参数异常 //预加载阶段的code说明 int CODE_PRELOAD_SUCCESS = 100;//预加载成功 int CODE_PRELOAD_UNDEFINED = 101;//未定义异常 int CODE_PRELOAD_HANDLE_DEX = 102;//dex加载异常 int CODE_PRELOAD_NOT_ZIP_FORMAT = 103;//基线dex非zip格式异常 int CODE_PRELOAD_REMOVE_BASEDEX = 105;//基线dex处理异常 //加载阶段的code说明 分三部分dex加载, resource加载, lib加载 //dex加载 int CODE_LOAD_UNDEFINED = 71;//未定义异常 int CODE_LOAD_AES_DECRYPT = 72;//aes对称解密异常 int CODE_LOAD_MFITEM = 73;//补丁SOPHIX.MF文件解析异常 int CODE_LOAD_COPY_FILE = 74;//补丁拷贝异常 int CODE_LOAD_SIGNATURE = 75;//补丁签名校验异常 int CODE_LOAD_SOPHIX_VERSION = 76;//补丁和补丁工具版本不一致异常 int CODE_LOAD_NOT_ZIP_FORMAT = 77;//补丁zip解析异常 int CODE_LOAD_DELETE_OPT = 80;//删除无效odex文件异常 int CODE_LOAD_HANDLE_DEX = 81;//加载dex异常 // 反射调用异常 int CODE_LOAD_FIND_CLASS = 82; int CODE_LOAD_FIND_CONSTRUCTOR = 83; int CODE_LOAD_FIND_METHOD = 84; int CODE_LOAD_FIND_FIELD = 85; int CODE_LOAD_ILLEGAL_ACCESS = 86; //resource加载 public static final int CODE_LOAD_RES_ADDASSERTPATH = 123;//新增资源补丁包异常 //lib加载 int CODE_LOAD_LIB_UNDEFINED = 131;//未定义异常 int CODE_LOAD_LIB_CPUABIS = 132;//获取primaryCpuAbis异常 int CODE_LOAD_LIB_JSON = 133;//json格式异常 int CODE_LOAD_LIB_LOST = 134;//lib库不完整异常 int CODE_LOAD_LIB_UNZIP = 135;//解压异常 int CODE_LOAD_LIB_INJECT = 136;//注入异常 3.2.6 setTags接口该参数设置端上拉取补丁包时的标签，可以支持条件更为丰富的灰度发布，以下为简单示例： 1234List&lt;String&gt; tags = new ArrayList&lt;&gt;();tags.add(&quot;test&quot;);//此处调用在queryAndLoadNewPatch()方法前SophixManager.getInstance().setTags(tags)； 1234List&lt;String&gt; tags = new ArrayList&lt;&gt;();tags.add(&quot;production&quot;);//此处调用在queryAndLoadNewPatch()方法前SophixManager.getInstance().setTags(tags)； &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如上，设置不同的tags，同一版本号下，可以打两个或者多个基线包，线上发布时用production的基线包，测试环境用test的基线包，这样就可以测试同一版本号下的同一个补丁了，两个环境互不影响。tags可以add多个，结构为前后非空字符串即可。生成补丁时，用同样tags的基线包和修复包。 4 版本管理说明&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;说明一：patch是针对客户端具体某个版本的，patch和具体版本绑定&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; - 应用当前版本号是1.1.0, 那么只能在后台查询到1.1.0版本对应发布的补丁, 而查询不到之前1.0.0旧版本发布的补丁.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;说明二：针对某个具体版本发布的新补丁, 必须包含所有的bugfix, 而不能依赖补丁递增修复的方式, 因为应用仅可能加载一个补丁&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; - 针对1.0.0版本在后台发布了一个补丁版本号为1的补丁修复了bug1, 然后发现此时针对这个版本补丁1修复的不完全, 代码还有bug2, 在后台重新发布一个补丁版本号为2的补丁, 那么此时补丁2就必须同时包含bug1和bug2的修复才行, 而不是只包含bug2的修复(bug1就没被修复了)","categories":[],"tags":[{"name":"android学习","slug":"android学习","permalink":"http://wongsuechang.github.io/tags/android%E5%AD%A6%E4%B9%A0/"},{"name":"app开发","slug":"app开发","permalink":"http://wongsuechang.github.io/tags/app%E5%BC%80%E5%8F%91/"}],"keywords":[]},{"title":"persistent=\"true\"分析","slug":"persistent-true分析","date":"2019-09-24T07:11:19.000Z","updated":"2019-10-29T19:53:36.000Z","comments":true,"path":"2019/09/24/persistent-true分析/","link":"","permalink":"http://wongsuechang.github.io/2019/09/24/persistent-true%E5%88%86%E6%9E%90/","excerpt":"","text":"一、标识persistent&#x3D;”true”的app启动过程&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在源码&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;res&#x2F;res&#x2F;values&#x2F;attrs_manifest.xml中这样描述： 1234&lt;!-- Flag to control special persistent mode of an application. This should not normally be used by applications; it requires that the system keep your application running at all times. --&gt;&lt;attr name=&quot;persistent&quot; format=&quot;boolean&quot; /&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置该属性的app有如下特点： * 在android系统启动的时候会自动启动； * app被强制杀掉后，系统会重新启动app，app必须安装在/system/app路径下。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;app在安装或者系统启动的时候解析androidmanifest.xml文件中的persistent属性，解析源码在/frameworks/base/core/java/com/android/content/pm/PackageParser.java 1234567891011121314151617private boolean parseBaseApplication(Package owner, Resources res, XmlPullParser parser, AttributeSet attrs, int flags, String[] outError) throws XmlPullParserException, IOException &#123; // ............ if ((flags&amp;PARSE_IS_SYSTEM) != 0) &#123; if (sa.getBoolean( com.android.internal .R.styleable.AndroidManifestApplication_persistent, false)) &#123; ai.flags |= ApplicationInfo.FLAG_PERSISTENT; &#125; &#125; // ............&#125; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;系统启动，在systemReady()加载所有persistent&#x3D;true的应用。 123456789101112131415161718192021public void systemReady(final Runnable goingCallback) &#123; // ............ try &#123; List apps = AppGlobals.getPackageManager() .getPersistentApplications(STOCK_PM_FLAGS); if (apps != null) &#123; int N = apps.size(); int i; for (i=0; i&lt;N; i++) &#123; ApplicationInfo info = (ApplicationInfo)apps.get(i); if (info != null &amp;&amp; !info.packageName.equals(&quot;android&quot;)) &#123; addAppLocked(info, false); &#125; &#125; &#125; &#125; catch (RemoteException ex) &#123; // pm is in same process, this will never happen. &#125; &#125; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;其中 getPersistentApplications()函数的定义如下： 12345678910111213141516171819202122232425262728public List&lt;ApplicationInfo&gt; getPersistentApplications(int flags) &#123; final ArrayList&lt;ApplicationInfo&gt; finalList = new ArrayList&lt;ApplicationInfo&gt;(); // reader synchronized (mPackages) &#123; final Iterator&lt;PackageParser.Package&gt; i = mPackages.values().iterator(); final int userId = UserId.getCallingUserId(); while (i.hasNext()) &#123; final PackageParser.Package p = i.next(); if (p.applicationInfo != null &amp;&amp; (p.applicationInfo.flags &amp; ApplicationInfo.FLAG_PERSISTENT) != 0 &amp;&amp; (!mSafeMode || isSystemApp(p))) &#123; PackageSetting ps = mSettings .mPackages.get(p.packageName); finalList.add(PackageParser.generateApplicationInfo(p, flags, ps != null ? ps.getStopped(userId) : false, ps != null ? ps.getEnabled(userId) : COMPONENT_ENABLED_STATE_DEFAULT, userId)); &#125; &#125; &#125; return finalList; &#125; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在PKMS中，有一个记录所有的程序包信息的哈希表（mPackages），每个表项中含有ApplicationInfo信息，该信息的flags（int型）数据中有一个专门的bit用于表示persistent。getPersistentApplications()函数会遍历这张表，找出所有persistent包，如果选中的persistent包是系统应用，或者当前系统处于非安全模式，则将persistent包添加到ArrayList。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;随后systemReady()开始遍历选中的ApplicationInfo，并对包名不为“android”的结点执行addAppLocked()。 12345678910111213141516171819202122232425262728293031323334353637383940final ProcessRecord addAppLocked(ApplicationInfo info, boolean isolated) &#123; ProcessRecord app; if (!isolated) &#123; app = getProcessRecordLocked(info.processName, info.uid); &#125; else &#123; app = null; &#125; if (app == null) &#123; app = newProcessRecordLocked(null, info, null, isolated); mProcessNames.put(info.processName, app.uid, app); if (isolated) &#123; mIsolatedProcesses.put(app.uid, app); &#125; updateLruProcessLocked(app, true, true); &#125; // This package really, really can not be stopped. try &#123; AppGlobals .getPackageManager() .setPackageStoppedState( info.packageName, false, UserId.getUserId(app.uid)); &#125; catch (RemoteException e) &#123; &#125; catch (IllegalArgumentException e) &#123; Slog.w(TAG, &quot;Failed trying to unstop package &quot; + info.packageName + &quot;: &quot; + e); &#125; if ((info.flags&amp;(ApplicationInfo.FLAG_SYSTEM|ApplicationInfo.FLAG_PERSISTENT)) == (ApplicationInfo.FLAG_SYSTEM|ApplicationInfo.FLAG_PERSISTENT)) &#123; app.persistent = true; app.maxAdj = ProcessList.PERSISTENT_PROC_ADJ; &#125; if (app.thread == null &amp;&amp; mPersistentStartingProcesses.indexOf(app) &lt; 0) &#123; mPersistentStartingProcesses.add(app); startProcessLocked(app, &quot;added application&quot;, app.processName); &#125; return app; &#125; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在AMS中，所谓的“add App”主要是指“添加一个与App进程对应的ProcessRecord节点”。在添加节点的动作完成以后，addAppLocked()还会检查App进程是否已经启动好了，如果尚未开始启动，此时就会调用startProcessLocked()启动这个进程。既然addAppLocked()试图确认App“正在正常运作”或者“将被正常启动”，那么其对应的package就不可能处于stopped状态。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;自此，我们已知设置了persistent&#x3D;”true”的应用是随着系统启动就即时启动了。 二、如何保持应用的持久性（persistent）&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本身persistent一词翻译过来即持久、固执的意思。在android系统内，persistent应用会随着系统启动而启动，一直持续到系统关机。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;为了保证这种持久性，persistent应用必须能够在异常出现时，自动重新启动。在Android里是这样实现的。每个ActivityThread中会有一个专门和AMS通信的binder实体——final ApplicationThread mAppThread。这个实体在AMS中对应的代理接口为IApplicationThread。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;当AMS执行到attachApplicationLocked()时，会针对目标用户进程的IApplicationThread接口，注册一个binder讣告监听器，一旦日后用户进程意外挂掉，AMS就能在第一时间感知到，并采取相应的措施。如果AMS发现意外挂掉的应用是persistent的，它会尝试重新启动这个应用。 1234567891011121314151617181920private final class AppDeathRecipient implements IBinder.DeathRecipient &#123; final ProcessRecord mApp; final int mPid; final IApplicationThread mAppThread; AppDeathRecipient(ProcessRecord app, int pid, IApplicationThread thread) &#123; if (localLOGV) Slog.v(TAG, &quot;New death recipient &quot; + this + &quot; for thread &quot; + thread.asBinder()); mApp = app; mPid = pid; mAppThread = thread; &#125; public void binderDied() &#123; if (localLOGV) Slog.v(TAG, &quot;Death received in &quot; + this + &quot; for thread &quot; + mAppThread.asBinder()); synchronized(ActivityManagerService.this) &#123; appDiedLocked(mApp, mPid, mAppThread); &#125; &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当其监听的binder实体死亡时，系统会回调AppDeathRecipient的binderDied()。 image &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般情况下，当一个应用进程挂掉后，AMS当然会清理掉其对应的ProcessRecord，这就是cleanUpApplicationRecordLocked()的主要工作。然而，对于persistent应用，cleanUpApplicationRecordLocked()会尝试再次启动对应的应用进程。","categories":[],"tags":[{"name":"android学习","slug":"android学习","permalink":"http://wongsuechang.github.io/tags/android%E5%AD%A6%E4%B9%A0/"},{"name":"frameworks","slug":"frameworks","permalink":"http://wongsuechang.github.io/tags/frameworks/"}],"keywords":[]}]}